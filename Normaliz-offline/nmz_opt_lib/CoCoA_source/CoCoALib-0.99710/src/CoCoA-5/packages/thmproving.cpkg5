Package $contrib/thmproving

export Collinear;
export OnCircle;
export LenSquare;
export Parallel;
export Perpendicular;
export EqualCos;
export EqualTan;
export IdealOfConditions;
export ProveThm;
export OptimalHypothesisIdeal;
export AlmostGoodSetOfConditions;

--     $contrib/thmproving.About();
--     $contrib/thmproving.Man();

Alias  TP   := $contrib/thmproving;

Define About()
  PrintLn "    Topic   : Theorem proving";
  PrintLn "    Keywords: Theorem proving, hypothesis, thesis, condition";
  PrintLn "    Authors : L. Bazzotti, G. Dalzotto";
  PrintLn "    Version : CoCoA 4.3";
  PrintLn "    Date    : 8 November 2000 (rev.3  27 May 2003)";
  PrintLn "    ";
  PrintLn "    Maintainer : J.Abbott";
  PrintLn "    Version  : CoCoA-5.3";
  PrintLn "    Date     : 20 Feb 2020";
EndDefine; -- About

------[   help & examples   ]--------

Define Man()
  PrintLn "Suggested alias for this package:";
  PrintLn "    Alias TP := $contrib/thmproving;";
  PrintLn "";
  PrintLn "SYNTAX";
  PrintLn "    -- here  POINT  means  [POLY, POLY]";
  PrintLn "    TP.Collinear(A: POINT, B: POINT, C: POINT): POLY";
  PrintLn "    TP.OnCircle(A: POINT, B: POINT, C: POINT, D: POINT): POLY";
  PrintLn "";
  PrintLn "    TP.LenSquare(AB: [POINT,POINT]): POLY";
  PrintLn "    TP.Parallel(AB: [POINT,POINT], CD: [POINT,POINT]): POLY";
  PrintLn "    TP.Perpendicular(AB: [POINT,POINT], CD: [POINT,POINT]): POLY";
  PrintLn "";
  PrintLn "    TP.EqualCos(ABC: [POINT,POINT,POINT], DEF: [POINT,POINT,POINT]): POLY";
  PrintLn "    TP.EqualTan(ABC: [POINT,POINT,POINT], DEF: [POINT,POINT,POINT]): POLY";
  PrintLn "";
  PrintLn "    TP.IdealOfConditions(HypothesisIdeal: IDEAL , ThesisIdeal: IDEAL): IDEAL";
  PrintLn "    TP.ProveThm(HypothesisIdeal: IDEAL , ThesisIdeal: IDEAL): RECORD";
  PrintLn "    TP.OptimalHypothesisIdeal(HypothesisIdeal: IDEAL, ConditionsIdeal: IDEAL)";
  PrintLn "                                                                     : IDEAL";
  PrintLn "    TP.AlmostGoodSetOfConditions(HypothesisIdeal: IDEAL, ConditionsIdeal:";
  PrintLn "                                                               IDEAL): LIST";
  PrintLn "";
  PrintLn "DESCRIPTION";
  PrintLn "";
  PrintLn "Given a putative theorem in Euclidean geometry, we introduce Cartesian";
  PrintLn "coordinates in the Euclidean plane, and translate the hypotheses and the";
  PrintLn "theses into algebraic relations.  This package deals with the problem of";
  PrintLn "determining whether this putative theorem is algebraically true.";
  PrintLn "";
  PrintLn "For more information and definitions of the terms used here, see the article:";
  PrintLn "Bazzotti, Dalzotto, Robbiano \"Remarks on Geometric Theorem Proving\"";
  PrintLn "which was published in Proceedings of the ADG-2000 conference,";
  PrintLn "LNAI, Springer-Verlag vol. 2061 pages 104--128.";
  PrintLn "";
  PrintLn "";
  PrintLn "The hypotheses and the theses can be translated into algebraic";
  PrintLn "relations using the following functions:";
  PrintLn "";
  PrintLn "TP.Collinear(A, B, C)";
  PrintLn "     returns a polynomial whose vanishing expresses that the points A,";
  PrintLn "     B and C are collinear.";
  PrintLn "TP.OnCircle(A, B, C, D),";
  PrintLn "     returns a polynomial whose vanishing expresses that the points A,";
  PrintLn "     B, C and D lie on a circle.";
  PrintLn "";
  PrintLn "TP.LenSquare([A,B])";
  PrintLn "     returns the square of the length of the segment connecting the";
  PrintLn "     points A and B.";
  PrintLn "TP.Parallel([A,B], [C,D]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the line";
  PrintLn "     through A and B and the line through C and D are parallel.";
  PrintLn "TP.Perpendicular([A,B], [C,D]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the line";
  PrintLn "     through A and B and the line through C and D are perpendicular.";
  PrintLn "";
  PrintLn "TP.EqualCos(ABC,DEF),";
  PrintLn "     returns a polynomial whose vanishing expresses that the cosines";
  PrintLn "     of the angles ABC and DEF are equal.";
  PrintLn "TP.EqualTan([A,B,C], [D,E,F]),";
  PrintLn "     returns a polynomial whose vanishing expresses that the tangents";
  PrintLn "     of the oriented angles ABC and DEF are equal.";
  PrintLn "";
  PrintLn "Let HypothesisIdeal be the ideal generated by the polynomials whose";
  PrintLn "vanishing expresses the hypotheses, and let ThesisIdeal be the ideal";
  PrintLn "generated by the polynomials whose vanishing express the theses of the";
  PrintLn "theorem.  Consider all the degeneracy conditions which can be seen";
  PrintLn "from the statement of the theorem.  Call DegeneratePoly their product,";
  PrintLn "compute Saturation(HypothesisIdeal,Ideal(DegeneratePoly)), and call";
  PrintLn "this ideal HypothesisIdeal again.";
  PrintLn "";
  PrintLn "TP.IdealOfConditions(HypothesisIdeal,ThesisIdeal),";
  PrintLn "     returns the Ideal of Conditions, i.e. the ideal of the";
  PrintLn "     polynomials f such that the theorem is algebraically true under";
  PrintLn "     the condition that f doesn't vanish.";
  PrintLn "";
  PrintLn "TP.ProveThm(HypothesisIdeal,ThesisIdeal),";
  PrintLn "  checks whether the theorem is algebraically true;";
  PrintLn "  the result is a Record whose field \"Statement\" says whether the";
  PrintLn "  putative theorem is true; if it is false, then there is another";
  PrintLn "  field \"ConditionIdeal\" giving the Ideal of Conditions.";
  PrintLn "";
  PrintLn "In the case the theorem is algebraically false, the following";
  PrintLn "functions help to understand why.";
  PrintLn "";
  PrintLn "TP.OptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal),";
  PrintLn "     returns the Optimal Hypothesis Ideal, i.e. an ideal which";
  PrintLn "     contains the hypothesis ideal, and whose prime components are";
  PrintLn "     exactly those on which the theorem is algebraically true.";
  PrintLn "";
  PrintLn "TP.AlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal),";
  PrintLn "     returns an Almost Good Set of Conditions, i.e. a list of list of";
  PrintLn "     not trivial conditions.";
  PrintLn "     Each list contains equivalent conditions, so a Good Set of";
  PrintLn "     Conditions is determined by choosing a representative condition";
  PrintLn "     in each list.";
  PrintLn "";
  PrintLn ">EXAMPLES<";
  PrintLn "";
  PrintLn "  Alias TP := $contrib/thmproving; -- proposed alias";
  PrintLn "";
  PrintLn "";
  PrintLn "";
  PrintLn "--Feet and Midpoints";
  PrintLn "--In every triangle the circle passing through the feet of the three";
  PrintLn "--altitudes intersects the sides of the triangle in their midpoints.";
  PrintLn "";
  PrintLn "     Use R ::= QQ[x[1..5],y[2..5]];";
  PrintLn "";
  PrintLn "-- Let A,B, and C be the vertices of a triangle.";
  PrintLn "-- WLOG A can be taken to be the origin (by a suitable translation),";
  PrintLn "-- and B can be taken to lie on the X axis (by a suitable rotation).";
  PrintLn "     A:=[0,0];        B:=[x[1],0];      C:=[x[2],y[2]];";
  PrintLn "";
  PrintLn "-- Let D, E and F be the feet of the altitudes.";
  PrintLn "     D:=[x[2],0];     E:=[x[3],y[3]];   F:=[x[4],y[4]];";
  PrintLn "";
  PrintLn "-- We shall also use O, the centre of the circle passing through D, E & F.";
  PrintLn "     O:=[x[5],y[5]];";
  PrintLn "";
  PrintLn "-- We shall show that M, the midpoint of side AB lies on the circle.";
  PrintLn "-- By symmetry, if one midpoint lies on the circle then they all will.";
  PrintLn "     M:=[x[1]/2,0];";
  PrintLn "";
  PrintLn "     H1 := TP.Collinear(F,A,C);                -- F lies on the edge AC";
  PrintLn "     H2 := TP.Perpendicular([A,C],[F,B]);      -- AC is perpendicular to FB";
  PrintLn "     H3 := TP.Collinear(E,C,B);                -- E lies on the edge BC";
  PrintLn "     H4 := TP.Perpendicular([A,E],[B,C]);      -- AE is perpendicular to BC";
  PrintLn "     H5 := TP.Perpendicular([D,C], [A,B]);";
  PrintLn "     H6 := TP.LenSquare([O,E]) - TP.LenSquare([O,D]); -- OE = OD as distances";
  PrintLn "     H7 := TP.LenSquare([O,D]) - TP.LenSquare([O,F]); -- OD = OF as distances";
  PrintLn "";
  PrintLn "     HypothesisIdeal := Ideal(H1,H2,H3,H4,H5,H6);";
  PrintLn "";
  PrintLn "--Now we exclude the case of a degenerate triangle.";
  PrintLn "     D1 := x[1];   ---- x[1]=0 means A=B";
  PrintLn "     D2 := y[2];   ---- y[2]=0 means C is on AB";
  PrintLn "     DegeneratePoly := D1*D2;";
  PrintLn "";
  PrintLn "     HypothesisIdeal := Saturation(HypothesisIdeal,Ideal(DegeneratePoly));";
  PrintLn "";
  PrintLn "     T1:= TP.LenSquare([O,M])-TP.LenSquare([O,D]);";
  PrintLn "     ThesisIdeal := Ideal(T1);";
  PrintLn "";
  PrintLn "     Thm := TP.ProveThm(HypothesisIdeal,ThesisIdeal);";
  PrintLn "   --The theorem is algebraically false. So you can find an Optimal";
  PrintLn "   --Hypothesis Ideal or an Almost Good Set of Conditions to";
  PrintLn "   --understand why the theorem is algebraically false.";
  PrintLn "";
  PrintLn "     ConditionIdeal := Thm.ConditionIdeal;";
  PrintLn "";
  PrintLn "     TP.OptimalHypothesisIdeal(HypothesisIdeal, ConditionIdeal);";
  PrintLn "   --In this case the Optimal Hypothesis Ideal is very difficult to read.";
  PrintLn "";
  PrintLn "";
  PrintLn "     TP.AlmostGoodSetOfConditions(HypothesisIdeal, ConditionIdeal);";
  PrintLn "   --This functions returns";
  PrintLn "     [[x[1]^2y[3] - x[4]^2y[3] - 2x[1]x[5]y[3] + 2x[4]x[5]y[3] +";
  PrintLn "     2x[1]x[5]y[4] - 2x[4]x[5]y[4] - y[2]y[4]^2 - 2x[1]^2y[5] + 2x[4]^2y[5]";
  PrintLn "     + 2y[2]y[3]y[5] + 2y[2]y[4]y[5] - 2y[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     x[4]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 - x[4]y[4]y[5],";
  PrintLn "     x[1]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 -";
  PrintLn "     2x[1]y[4]y[5] + 2x[3]y[4]y[5] - x[4]y[4]y[5],";
  PrintLn "";
  PrintLn "     x[1]y[4]^2 - x[3]y[4]^2 - 2x[1]y[4]y[5] + 2x[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     x[3]y[4]^3 - 2x[5]y[4]^3 - 2x[3]y[4]^2y[5] + 2x[4]y[4]^2y[5] +";
  PrintLn "     4x[5]y[4]^2y[5] - 4x[4]y[4]y[5]^2,";
  PrintLn "";
  PrintLn "     x[4]x[5]y[4]^3 - 2x[5]^2y[4]^3 + 1/2y[2]y[4]^4 + 4x[5]^2y[4]^2y[5]";
  PrintLn "     - y[2]y[4]^3y[5] + y[4]^4y[5] - 4x[4]x[5]y[4]y[5]^2 -";
  PrintLn "     2y[4]^3y[5]^2,";
  PrintLn "";
  PrintLn "     x[4]^2y[4]^3 - 4x[5]^2y[4]^3 + y[2]y[4]^4 + y[4]^5 +";
  PrintLn "     4x[4]x[5]y[4]^2y[5] + 8x[5]^2y[4]^2y[5] - 2y[2]y[4]^3y[5] -";
  PrintLn "     4x[4]^2y[4]y[5]^2 - 8x[4]x[5]y[4]y[5]^2 - 4y[4]^3y[5]^2,";
  PrintLn "";
  PrintLn "     x[3]y[2] - 2x[5]y[2] + x[1]y[3] - x[4]y[3] - x[3]y[4] + 2x[5]y[4]";
  PrintLn "     - 2x[1]y[5] + 4x[2]y[5] - 2x[4]y[5],";
  PrintLn "";
  PrintLn "     x[1]y[2] - 2x[5]y[2] - x[3]y[4] + 2x[5]y[4] - 2x[1]y[5] +";
  PrintLn "     4x[2]y[5] - 2x[4]y[5],";
  PrintLn "";
  PrintLn "     x[4]y[2] - x[3]y[4],";
  PrintLn "";
  PrintLn "     x[2]y[4] - x[3]y[4],";
  PrintLn "";
  PrintLn "     x[1]x[2] - x[4]^2 - y[2]y[4] + y[3]y[4] - y[4]^2,";
  PrintLn "";
  PrintLn "     x[2]^2 - x[4]^2 - y[2]y[4] + 2y[3]y[4] - y[4]^2,";
  PrintLn "";
  PrintLn "     x[2]x[4] - x[4]^2 + y[3]y[4] - y[4]^2,";
  PrintLn "";
  PrintLn "     x[2]x[5] - x[4]x[5] - 1/2y[2]y[4] + y[3]y[4] - y[4]y[5],";
  PrintLn "";
  PrintLn "     x[2]y[3] - x[4]y[3],";
  PrintLn "";
  PrintLn "     x[3]y[3]y[4] - x[5]y[3]y[4] - 1/2x[3]y[4]^2 + x[5]y[4]^2 - x[4]y[4]y[5],";
  PrintLn "";
  PrintLn "     x[3]x[5]y[4] - x[4]x[5]y[4] - 1/2y[2]y[4]^2 + 2y[3]y[4]y[5] - y[4]^2y[5],";
  PrintLn "";
  PrintLn "     x[3]x[4]y[4] - x[4]^2y[4] - y[4]^3 + 2y[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     y[3]^2y[4] - 2y[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     y[2]y[3]y[4] - 2y[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     y[3]y[4]^2 - 2y[3]y[4]y[5],";
  PrintLn "";
  PrintLn "     x[5]^2y[2] - 1/2x[1]x[5]y[3] + 1/2x[4]x[5]y[3] - 1/4y[2]^2y[3] -";
  PrintLn "     x[5]^2y[4] - 1/4y[2]^2y[4] + x[1]x[5]y[5] - x[4]x[5]y[5] +";
  PrintLn "     1/2y[2]y[3]y[5] - 3/2y[2]y[4]y[5] + 3y[3]y[4]y[5] - 2y[4]y[5]^2]]";
  PrintLn "";
  PrintLn "   --There is only one list of equivalent conditions.  We can pick";
  PrintLn "   --the one we like best (i.e. the simplest one): x[2]y[3] - x[4]y[3]";
  PrintLn "   --The theorem is algebraically true under the condition that";
  PrintLn "   --x[2]y[3] - x[4]y[3] doesn't vanish, which means that the triangle";
  PrintLn "   --is not right-angled.";
  PrintLn "";
  PrintLn "";
  PrintLn "";
  PrintLn "---Pappus's Theorem";
  PrintLn "-- Let A, B, C be three points on a line, and let D, E, F  be three points";
  PrintLn "-- on another line. Let S be the intersection point of BD and AE, Q the";
  PrintLn "-- intersection point of CD and AF, P the intersection point of EC and";
  PrintLn "-- BF. Then P, Q, S are collinear.";
  PrintLn "";
  PrintLn "   Use R ::= QQ[x[1..8],y[3..8]];";
  PrintLn "";
  PrintLn "     A:=[0,0];         B:=[x[1],0];      C:=[x[2],0];";
  PrintLn "     D:=[x[3],y[3]];   E:=[x[4],y[4]];   F:=[x[5],y[5]];";
  PrintLn "     P:=[x[6],y[6]];   Q:=[x[7],y[7]];   S:=[x[8],y[8]];";
  PrintLn "";
  PrintLn "     H1 := TP.Collinear(D,E,F);";
  PrintLn "     H2 := TP.Collinear(S,B,D);";
  PrintLn "     H3 := TP.Collinear(S,A,E);";
  PrintLn "     H4 := TP.Collinear(Q,C,D);";
  PrintLn "     H5 := TP.Collinear(Q,A,F);";
  PrintLn "     H6 := TP.Collinear(P,E,C);";
  PrintLn "     H7 := TP.Collinear(P,B,F);";
  PrintLn "     HypothesisIdeal := Ideal(H1,H2,H3,H4,H5,H6,H7);";
  PrintLn "";
  PrintLn "     DegeneratePoly := y[3]y[4]y[5];";
  PrintLn "";
  PrintLn "     HypothesisIdeal := Saturation(HypothesisIdeal,Ideal(DegeneratePoly));";
  PrintLn "";
  PrintLn "     T1 := TP.Collinear(P,Q,S);";
  PrintLn "     ThesisIdeal := Ideal(T1);";
  PrintLn "";
  PrintLn "     TP.ProveThm(HypothesisIdeal, ThesisIdeal);";
  PrintLn "   --In this case the theorem is algebraically true with the new";
  PrintLn "   --HypothesisIdeal, so the theorem is true if none of D, E, F is";
  PrintLn "   --on the line through A, B and C.";
  PrintLn "";
  PrintLn "---Theorem of Degenerate Parallelogram";
  PrintLn "-- Given a parallelogram, the intersection point of the diagonals lies";
  PrintLn "-- on a side.";
  PrintLn "";
  PrintLn "   Use R ::= QQ[x[1..4],y[2..4]];";
  PrintLn "";
  PrintLn "   A := [0,0];        B := [x[1],0];";
  PrintLn "   C := [x[2],y[2]];  D := [x[3],y[3]];";
  PrintLn "   O := [x[4],y[4]];";
  PrintLn "";
  PrintLn "   H1 := TP.Parallel([A,B],[D,C]);";
  PrintLn "   H2 := TP.Parallel([A,D],[B,C]);";
  PrintLn "   H3 := TP.Collinear(O,A,C);";
  PrintLn "   H4 := TP.Collinear(O,D,B);";
  PrintLn "   HypothesisIdeal := Ideal(H1,H2,H3,H4);";
  PrintLn "";
  PrintLn "   T1 := TP.Collinear(O,A,B);";
  PrintLn "   ThesisIdeal := Ideal(T1);";
  PrintLn "";
  PrintLn "   Thm := TP.ProveThm(HypothesisIdeal,ThesisIdeal);";
  PrintLn " --The theorem is algebraically false.";
  PrintLn "";
  PrintLn "   ConditionsIdeal := Thm.ConditionsIdeal;";
  PrintLn "";
  PrintLn "   TP.AlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal);";
  PrintLn " --In this case the Almost Good Set Of Conditions is very hard to";
  PrintLn " --read, so try to calculate an Optimal Hypothesis Ideal.";
  PrintLn "";
  PrintLn "   TP.OptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal);";
  PrintLn " --This function returns the ideal";
  PrintLn "   Ideal(";
  PrintLn "   x[1]y[4],";
  PrintLn "   x[3]y[2] - x[2]y[3],";
  PrintLn "   x[4]y[2] - x[2]y[4],";
  PrintLn "   x[4]y[3] - x[3]y[4],";
  PrintLn "   x[1]y[2],";
  PrintLn "   x[1]y[3])";
  PrintLn " --whose meaning is clear. You  conclude that the theorem is";
  PrintLn " --algebraically true for the parallelograms which degenerate into a";
  PrintLn " --segment.";
EndDefine; -- Man

------[   Main functions   ]--------

Define Collinear(A, B, C)
  return (C[1]-A[1])*(C[2]-B[2])-(C[2]-A[2])*(C[1]-B[1]);
EndDefine; -- Collinear

Define Parallel(AB, CD)
  A := AB[1];  B := AB[2];
  C := CD[1];  D := CD[2];
  return (B[1]-A[1])*(D[2]-C[2])-(B[2]-A[2])*(D[1]-C[1]);
EndDefine; -- Parallel

Define Perpendicular(AB, CD)
  A := AB[1];  B := AB[2];
  C := CD[1];  D := CD[2];
  return (B[1]-A[1])*(D[1]-C[1])+(B[2]-A[2])*(D[2]-C[2]);
EndDefine; -- Perpendicular

Define LenSquare(AB)
  A := AB[1];  B := AB[2];
  return (B[1]-A[1])^2+(B[2]-A[2])^2;
EndDefine; -- LenSquare


Define EqualTan(ABC, DEF)
  A := ABC[1];  B := ABC[2];   C := ABC[3];
  D := DEF[1];  E := DEF[2];   F := DEF[3];
  BA := [B, A];  BC := [B, C];
  ED := [E, D];  EF := [E, F];
  return  ($.Y(BA)*$.X(BC) - $.Y(BC)*$.X(BA)) *
          ($.X(ED)*$.X(EF) + $.Y(ED)*$.Y(EF)) -
          ($.Y(ED)*$.X(EF) - $.Y(EF)*$.X(ED)) *
          ($.X(BA)*$.X(BC) + $.Y(BA)*$.Y(BC));
EndDefine; -- EqualTan

Define OnCircle(A, B, C, D)
  ABC := [A, B, C];
  ADC := [A, D, C];
  return $.EqualTan(ABC, ADC);
EndDefine; -- OnCircle

Define EqualCos(ABC, DEF)
  A := ABC[1];  B := ABC[2]; C := ABC[3];
  D := DEF[1];  E := DEF[2]; F := DEF[3];
  BA := [B, A]; BC := [B, C];
  ED := [E, D]; EF := [E, F];
  Num_1 := $.X(BA)*$.X(BC) + $.Y(BA)*$.Y(BC);
  Num_2 := $.X(ED)*$.X(EF) + $.Y(ED)*$.Y(EF);
  Pol := Num_1^2*$.LenSquare(ED)*$.LenSquare(EF)-
         Num_2^2*$.LenSquare(BA)*$.LenSquare(BC);
  return Pol;
EndDefine; -- EqualCos

-------------------- --------------------

Define IdealOfConditions(HypothesisIdeal, ThesisIdeal)
  return Saturation(HypothesisIdeal,ThesisIdeal);
EndDefine; -- IdealOfConditions


Define ProveThm(HypothesisIdeal, ThesisIdeal)
  IC := $.IdealOfConditions(HypothesisIdeal,ThesisIdeal);
  if 1 isin IC then
    return record[Statement:=true];
  else
    return record[Statement:=false, ConditionIdeal:=IC];
  endif;
EndDefine; -- ProveThm

Define OptimalHypothesisIdeal(HypothesisIdeal,ConditionsIdeal)
  return Saturation(HypothesisIdeal,ConditionsIdeal);
EndDefine; -- OptimalHypothesisIdeal


Define AlmostGoodSetOfConditions(HypothesisIdeal,ConditionsIdeal)
  P := RingOf(HypothesisIdeal); // assume this is a polyring
  K := CoeffRing(P); // assume this is a field
  nvars := NumIndets(P);
  TheoremProvingNewRing := NewPolyRing(K, concat(SymbolRange("x",1,nvars), ["z"]));
  z := indet(TheoremProvingNewRing, NumIndets(TheoremProvingNewRing));
  IntoNewRing := PolyAlgebraHom(P, TheoremProvingNewRing, first(indets(TheoremProvingNewRing),nvars));
  BackToOrigRing := PolyAlgebraHom(TheoremProvingNewRing, P, concat(indets(P), [zero(P)]));
//  TheoremProvingNewRing ::=  CoeffRing[x[1..NumIndets()], z];
//  Using TheoremProvingNewRing Do
  Hyp := ideal([IntoNewRing(gen) | gen in gens(HypothesisIdeal)]);
  IC := ideal([IntoNewRing(gen) | gen in gens(ConditionsIdeal)]);
  Conditions := Gens(IC);
  ListOfConditionsAndIdeals :=
    [ record[Ideal:=Elim(z,Hyp+Ideal(C*z-1)), Poly:=C] | C In Conditions];
    if [ X in ListOfConditionsAndIdeals | not(1 isin X.Ideal) ] = [] then
      return  [];
    endif;
    AlmostGoodList := [];
    foreach ElementOfL in ListOfConditionsAndIdeals do
      Inserted := false;
      I := 1;
      while I <= Len(AlmostGoodList) and not(Inserted) do
	if AlmostGoodList[I].Ideal = ElementOfL.Ideal then
	  append(ref AlmostGoodList[I].Polys, ElementOfL.Poly);
	  Inserted := true;
	elif IsContained(ElementOfL.Ideal, AlmostGoodList[I].Ideal)  then
	  AlmostGoodList[I] := record[Ideal:=ElementOfL.Ideal,
				      Polys:=[ElementOfL.Poly]];
	  Inserted := true;
	elif IsContained(AlmostGoodList[I].Ideal, ElementOfL.Ideal) then
	  Inserted := true;
	endif;
	I := I+1;
      endwhile;
      if not(Inserted) then
	append(ref AlmostGoodList, record[Ideal:=ElementOfL.Ideal,
 	                              Polys:=[ElementOfL.Poly]]);
      endif;
    endforeach;
    AlmostGood := [X.Polys | X In AlmostGoodList];
//  EndUsing;
  return [apply(BackToOrigRing,PolyList) | PolyList in AlmostGood];
EndDefine; -- AlmostGoodSetOfConditions





------[   Auxiliary functions   ]--------

Define X(AB)
  -- Computes the component x of the vector AB
  A := AB[1];  B := AB[2];
  return B[1]-A[1];
EndDefine; -- X

Define Y(AB)
  -- Computes the component y of the vector AB
  A := AB[1];  B := AB[2];
  return B[2]-A[2];
EndDefine; -- Y


EndPackage; -- contrib/thmproving
